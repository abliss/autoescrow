package rps;

message Player {
    // public key for verifying this player's signatures
    optional string pubKey = 1;
    // BTC address to receive player's winnings
    optional string wallet = 2;
}

message GameHeader {
    // hash of the evaluator object for this game
    optional string evaluator = 1;
    // who is playing the game
    repeated Player players = 2;
    // fixed fee for the autoescrow server for handling this game, in satoshi
    optional uint64 rake = 3;
    // hash of a recent block in the bitcoin blockchain, establishing timestamp
    optional bytes blockStamp = 4;
    // maximum length of a turn, in bitcoin blocks
    optional uint32 blockLimit = 5;
    // To uniquify this game
    optional uint32 nonce = 6;
}


// The spud-salt-hash system is a method for communally choosing a random number
// in a specified range [0..r]. First, each player chooses a secret random
// number in the range, which is called that player's spud.  The player then
// chooses 32 random bytes and adds them to the spud to produce a Salt.  The
// player now hashes the Salt and publishes the hash in the turn chain.  Once
// all players have published hashes, each player in turn reveals the secret
// Salt and publishes it to the turn chain.  Once all players have published
// their Salts, the spud from each salt is added together and taken modulo r to
// compute the final spud.  (TODO: Once all players have signed the final spud,
// the two rounds devoted to computing it could be removed from the turn chain
// to save space.)
message Salt {
    optional uint32 spud = 1;
    optional bytes random = 2;
}
message Turn {
    // Index of the player making this turn
    optional uint32 who = 1;
    // A hash of a secret salt, which will be revealed in this player's next turn.
    optional bytes hash = 2;
    // the Salt corresponding to this player's last hash.
    optional Salt salt = 3;
    // the spud computed from the previous round.
    optional uint32 spud = 4;
    // a game-specific choice from the current player from a predetermined range.
    optional uint32 choice = 5;
}

message GameState {
    // The GameHeader object
    optional gameHeader gameHeader = 1;
    // 1 turn object from each player in round-robin.
    repeated Turn turns = 2;
}

message SignedGameState {
    // The GameState to be signed
    optional GameState gameState = 1;
    // one signature from each player, approving the last GameState they saw.
    // Let n = gameState.turns.length and m = players.length.  When n == 0, each
    // player i signs the gameHash in signatures[i], signifying their
    // willingness to play the game.  When n > 0, t = (n - 1) % m is the index
    // of the player who took the last turn.  That player signs the gameState
    // into signatures[t] and copies all other signatures in-place.
    repeated bytes signatures = 2;
}
